# Comparaison entre les résultats

Dans ce chapitre, une comparaison entre les deux codes est proposée.
Afin de faire un petit rappel, on a comme code :

- GVDB-Voxel: ce code est une implémentation de la méthode SPH en tirant profit des technologies de Nvidia
- FluidX3D: ce code est une implémentation de la méthode LBM en utilisant OpenCL, ce qui rend le code exécutable sur tous les GPUs.

La comparaison a donc impliqué d'essayer de faire des exemples similaires afin de pouvoir comparer au mieux les deux implémentations des méthodes.

La stabilité numérique des deux méthodes SPH et LBM repose principalement sur l'initialisation de celles-ci, c'est pourquoi la recherche des paramètres rendant les deux méthodes identiques est un problème très complexe.

## Initialisation de la simulation

La condition initiale joue un rôle crucial dans la comparaison des deux codes car l'objectif est de comparer les deux codes grâce à la modélisation du même phénomène physique.
La première idée était de modéliser une goutte, en forme de cube car plus facile à définir, tombant dans un bassin d'eau, comme il est possible de voir sur la figure [-@fig-idee-1].

![Idée initiale](../images/idee-1.png){#fig-idee-1}

À cet exemple, le travail a montré que la définition d'un bac d'eau était presque impossible dans l'implémentation de la méthode SPH, car celle-ci possède des instabilités au niveau des bords du domaine, c'est pourquoi le fluide implosait ou s'éparpillait en volant dans tout le domaine, comme il est possible de voir sur la figure [-@fig-problem-1].
En plus du phénomène d'implosion, le code s'arrêtait au bout d'un petit moment à cause d'accès illégaux à la mémoire.

::: {#fig-problem-1 layout-ncol=2}

![Condition initiale](../images/problem-1-1.png)

![Implosion](../images/problem-1-2.png){width=86%}

Difficulté de définir un bac d'eau
:::

Face à ces difficultés, la solution finale a été de renoncer à cette comparaison qui aurait été idéale car elle aurait permis de faire varier la quantité d'eau dans le bac, permettant de voir à quel point le code avec domaine adaptatif était avantagé comparé à l'autre code qui aurait eu plus de peine à tourner pour un bac très rempli d'eau car il aurait dû calculer ce qui se passe au fond du bac, ce qui n'aurait pas été le cas du code avec domaine adaptatif.

C'est pourquoi l'exemple choisi est un exemple fonctionnel modifié de la méthode SPH.

Il s'agit d'un cuboïd d'eau tombant dans un bac, comme il est possible de voir sur la séquence d'images [-@fig-sequence].
Cet exemple a été reproduit dans les deux codes, c'est pourquoi la séquence d'images [-@fig-sequence] est celle de FluidX3D.
Dans l'exemple original, il y avait ensuite une force fréquentielle qui créait des vagues dans le bac, mais celle-ci a été supprimée afin de pouvoir avoir le même exemple dans les deux codes.


::: {#fig-sequence layout-nrow=2}

![](../images/seq1.png)

![](../images/seq2.png)

![](../images/seq3.png)

![](../images/seq4.png)

![](../images/seq5.png)

![](../images/seq6.png)

Séquence d'images de la simulation
:::

Comme le code GVDB est conçu pour modéliser des simulations à grande échelle comme l'océan par exemple et que le code de FluidX3D est plus dans le domaine du mètre, les deux exemples ne sont théoriquement pas identiques, c'est pourquoi les paramètres ont été définis afin que les deux codes donnent visuellement les mêmes résultats.

Ainsi, ce ne sera pas une comparaison quantitative, mais qualitative qui sera faite.

Il est possible de voir sur la figure [-@fig-quality] 3 résolutions différentes pour FluidX3D et une résolution pour GVDB-Voxel.

Pour chacune des résolutions de FluidX3D, le paramètre de tension de surface a été ajusté afin d'avoir un résultat qualitativement similaire à GVDB-Voxel.

Afin de faciliter la prise de décision, un rendu très basique a été effectué sur FluidX3D en n'utilisant que de la rastérisation et non du raytracing. 

Comme la figure [-@fig-quality] montre, la perspective n'est pas présente dans GVDB-Voxel, à la différence de FluidX3D.

De plus, en comparant les résultats visuels de la figure [-@fig-problem-1] et de la figure [-@fig-quality], il apparaît que l'isosurface est calculée dans le cas de FluidX3D, mais pas dans le cas de GVDB-Voxel, l'isosurface étant ce qui permet de passer d'une représentation discrète du fluide comme un ensemble de particules à une représentation lisse.

::: {#fig-quality layout-nrow=2}

![GVDB: 1500000 particules](../images/gvdb-voxel-key-1.png){width=85%}

![FluidX3D: Résolution de 4000000](../images/seq5.png)

![FluidX3D: Résolution de 32000000](../images/domain_normal_simple.png)

![FluidX3D: Résolution de 108000000](../images/domain_3_2_simple.png)

Comparaison des qualités
:::

Sur la figure [-@fig-quality], la résolution de FluidX3D semblant équivalente à la résolution de GVDB-Voxel est la résolution de $4 \cdot 10^6$.

En effet, les résolutions de $32 \cdot 10^6$ et $108 \cdot 10^6$ donnent plus de détails que GVDB-Voxel quant à la crête des vagues.

Ainsi, ce sera la résolution de $4 \cdot 10^6$ qui sera utilisée afin de comparer les deux codes.

Les tailles des domaines ont été choisies afin d'obtenir un résultat similaire.

Dans le cas de GVDB-Voxel, le domaine est de taille $400 \times 400 \times 200$ tandis que dans le cas de FluidX3D, le domaine est de taille $200 \times 200 \times 100$.

Ainsi, les deux domaines sont proportionnels, mais pas identique car la résolution de FluidX3D est contrôlée par la taille du domaine.

Comme le code de GVDB-Voxel possède $1.5 \cdot 10^6$ particules, les propriétés de celles-ci telle que leur position, leur vitesse, leur masse etc doivent être stockées.

À la différence, dans le code de FluidX3D, comme le domaine est de taille $200 \times 200 \times 100$, la résolution est de $200 \cdot 200 \cdot 100 = 4 \cdot 10^6$ donnant les informations de $4\cdot 10^6$ lattices à stocker.
Le code de FluidX3D tourne en D3Q19 [-@sec-lbm], ce qui signifie que la discrétisation de la vélocité donne 19 valeurs à stocker.
Donc pour chaque lattice, au moins 19 valeurs sont à stocker ne serait-ce que pour la vélocité.
Ainsi, le code de FluidX3D devrait utiliser plus de mémoire que le code de GVDB-Voxel.

Pour la comparaison des deux méthodes, comme le code de GVDB-Voxel utilise du raytracing natif CUDA s'apparentant à de la rastérisation, le code de FluidX3D a été évalué avec et sans raytracing.

### Moments clés

Lors de la simulation, 2 moments clés ont été défini.
Le premier moment clé est utilisé afin d'ajuster la viscosité pour avoir un résultat similaire entre FluidX3D et GVDB-Voxel, et le deuxième moment clé indique la fin de la simulation, comme il est possible de voir sur la figure [-@fig-key].

:::{#fig-key layout-ncol=2}

![](../images/gvdb-voxel-key-1.png)

![](../images/seq5.png)

![](../images/gvdb-voxel-key-2.png)

![](../images/seq6.png)

Moments clés
:::

Sur la figure [-@fig-key], il est possible de remarquer que le volume d'eau n'est pas le même dans le code de GVDB que dans le code de FluidX3D.
En effet, le fluide s'écrase et se compresse systématiquement sur GVDB-Voxel, comme montré sur la figure [-@fig-compress].

:::{#fig-compress layout-ncol=2}

![Initialisation](../images/compress-init.png){width=60%}

![Compression](../images/compress-final.png){width=60%}

Phénomène de compression dans GVDB
:::

Afin de résoudre le phénomène de compression, un jeu sur de nombreux paramètres du code de GVDB-Voxel, tel que sur la taille des particules, l'espacement, la densité, etc, a été effectué, mais sans succès.

## Exécution des codes {#sec-comparaison}

Dans cette partie, l'objet d'étude sera l'exécution des deux codes.

Les deux codes donnent une visualisation en temps réelle, c'est à dire que le rendu est exécuté en même temps que le calcul de la simulation.

Afin d'évaluer les performances des deux codes, un script bash a été créé afin de reporter l'utilisation du CPU, de la RAM, et du GPU dans un fichier `csv`.

À cet instant du travail, un soucis s'est présenté car le code de FluidX3D ne fonctionne pas en visualisation temps réel sur le linux de nom ordinateur car des erreurs XrandR sont apparues lors de l'exécution du code, erreurs qui sont restées irrésolues faute de temps et de documentation sur la provenance de ces erreurs.
Mes suppositions à l'heure actuelle sont que Nvidia utilise X11 avec Xinemara qui est une autre version de XrandR, rendant l'affichage incompatible avec mon ordinateur linux.
La solution n'étant pas trouvée, l'enregistrement des performances a été effectué sous Windows pour le code de FluidX3D,
ce qui ne devait pas être trop problématique étant donné que les données principales qui nous intéressent, à savoir l'utilisation du GPU, se prennent avec `nvidia-smi` sur linux et Windows.
Cependant, il a fallut traduire le script bash en script powershell, ce qui s'est fait avec l'aide de ChatGPT et des discussions sur les forums et les blogs.

Enfin, la visualisation des données a été faite à l'aide de python et de ChatGPT qui a donné le squelette du code, permettant d'économiser du temps de codage au profil du rapport.

Les résultats obtenus sont alors donnés sur les figures [-@fig-1] et [-@fig-g1].

::: {#fig-results layout-nrow=2}

```{python}
#| label: fig-1
#| fig-cap: FluidX3D résolution 32000000

import matplotlib.pyplot as plt
import pandas as pd

# Lire les données du fichier CSV
log_file = "../../../FluidX3D/logs/usage_stats_5.csv"

def fluidx3d(log_file: str = 'domain_divide_by_2_simple.csv'):
    df = pd.read_csv("../../../FluidX3D/logs/" + log_file)
    
    # Afficher les premières lignes pour vérifier le contenu
    #print(df.head())
    
    # Convertir la colonne 'Timestamp' en datetime
    df["Timestamp"] = pd.to_datetime(df["Timestamp"])
    
    # Calculer les secondes depuis le début
    start_time = df["Timestamp"].iloc[0]
    df["Seconds_Since_Start"] = (df["Timestamp"] - start_time).dt.total_seconds()
    
    # Tracer les graphiques de l'utilisation du CPU, de la mémoire et du GPU
    plt.figure(figsize=(14, 7))
    plt.plot(df["Seconds_Since_Start"], df["CPU_Usage(%)"], label="Utilisation CPU (%)")
    # plt.plot(df["Seconds_Since_Start"], df["Memory_Usage(%)"], label="Utilisation Mémoire CPU (%)",)
    plt.plot(df["Seconds_Since_Start"], df["RAM_Usage(%)"], label="Utilisation RAM (%)")
    plt.plot(df["Seconds_Since_Start"], df["GPU_Usage(%)"], label="Utilisation GPU (%)")
    plt.plot(
        df["Seconds_Since_Start"],
        df["GPU_Memory_Usage(%)"],
        label="Utilisation Mémoire GPU (%)",
    )
    plt.plot(
        df["Seconds_Since_Start"],
        df["GPU_Memory_Access_Usage(%)"],
        label="Accès à la Mémoire GPU (%)",
    )
    plt.xlabel("Temps (secondes)")
    plt.ylabel("Utilisation (%)")
    plt.title(
    "Utilisation du CPU, de la Mémoire CPU, du GPU, de la Mémoire GPU, des accès à la mémoire GPU et de la RAM"
    )
    plt.legend()
    plt.grid(True)
    plt.show()
fluidx3d()
```

```{python}
#| label: fig-g1
#| fig-cap: GVDB Voxel 1500000 particules

import matplotlib.pyplot as plt
import pandas as pd

# Lire les données du fichier CSV
log_file = "../../../gvdb-voxels/logs"
def gvdb(log_file: str = 'domain_normal.csv'):
    df = pd.read_csv("../../../gvdb-voxels/logs/" + log_file)
    
    # Afficher les premières lignes pour vérifier le contenu
    # print(df.head())
    
    # Convertir la colonne 'Timestamp' en datetime
    df["Timestamp"] = pd.to_datetime(df["Timestamp"])
    
    # Calculer les secondes depuis le début
    start_time = df["Timestamp"].iloc[0]
    df["Seconds_Since_Start"] = (df["Timestamp"] - start_time).dt.total_seconds()
    
    # Tracer les graphiques de l'utilisation du CPU, de la mémoire et du GPU
    plt.figure(figsize=(14, 7))
    plt.plot(df["Seconds_Since_Start"], df["CPU_Usage(%)"], label="Utilisation CPU (%)")
    # plt.plot(df["Seconds_Since_Start"], df["Memory_Usage(%)"], label="Utilisation Mémoire CPU (%)",)
    plt.plot(df["Seconds_Since_Start"], df["RAM_Usage(%)"], label="Utilisation RAM (%)")
    plt.plot(df["Seconds_Since_Start"], df["GPU_Usage(%)"], label="Utilisation GPU (%)")
    plt.plot(
        df["Seconds_Since_Start"],
        df["GPU_Memory_Usage(%)"],
        label="Utilisation Mémoire GPU (%)",
    )
    plt.plot(
        df["Seconds_Since_Start"],
        df["GPU_Memory_Access_Usage(%)"],
        label="Accès à la Mémoire GPU (%)",
    )
    plt.xlabel("Temps (secondes)")
    plt.ylabel("Utilisation (%)")
    plt.title(
    "Utilisation du CPU, de la Mémoire CPU, du GPU, de la Mémoire GPU, des accès à la mémoire GPU et de la RAM"
    )
    plt.legend()
    plt.grid(True)
    plt.show()
gvdb()
```

Résultats obtenus pour GVDB-Voxel et FluidX3D
::: 

Il est possible d'observer à la fin du graphique de la figure [-@fig-1] que toutes les valeurs diminuent soudainement.
Cela est causé par un signal d'arrêt envoyé au programme entre l'enregistrement de 2 mesures, donnant une valeur mauvaise car la mesure utilise le PID du processus en cours d'exécution, qui est détruit par le signal.
De plus, au début de l'exécution du code, le CPU est légèrement solicité afin de tout mettre en place pour la simulation.


Il en résulte une différence d'un facteur $10$ entre le temps d'exécution de la technique de FluidX3D, qui est seulement à $30$ secondes, et la technique GVDB-Voxel, qui est maintenant à $300$ secondes, ce qui laisse présumer que la méthode FluidX3D, malgré son usage plus grand de la mémoire, est plus rapide que la méthode GVDB-Voxel.
De plus, lorsque le nombre de particules a augmenté, le pourcentage de la mémoire GPU a diminué, ce qui est contre intuitif, c'est pourquoi des tests sur la mémoire GPU utilisé sont effectués dans la suite de l'étude.

Un cas intéressant serait maintenant d'essayer d'avoir le code FluidX3D avec le même pourcentage d'utilisation de la mémoire GPU, ce qui a été effectué sur la figure [-@fig-2] par une division du domaine du fluide par 2.
Cependant, comme il est possible de constater sur la figure, le code ne met que $3$ secondes environ à s'exécuter, ce qui signifie que pour une qualité équivalente, le code de FluidX3D met $10$ fois moins de temps à s'exécuter.

Mais il est possible de remarquer malgré un faible nombre de valeurs que l'utilisation de la mémoire GPU est toujours élevée car elle est d'environ $40$ pourcent.

```{python}
#| label: fig-2
#| fig-cap: FluidX3D résolution 4000000
fluidx3d('domain_divide_by_2.csv')
```
### Utilisation de la mémoire GPU

Afin d'étudier l'utilisation de la mémoire GPU, un test a été fait en prenant $\frac{3}{2}$ du domaine [-@fig-3], puis en prenant $2$ fois le domaine [-@fig-4].
Lors de la multiplication par $4$ du domaine, la simulation a été stoppée avant l'instant clé car elle allait prendre quelques heures.
Cependant, cela suffit pour observer le pourcentage d'utilisation de la mémoire GPU.
Il est aisément possible d'observer que le pourcentage d'utilisation de la mémoire GPU diminue en fonction de la résolution, ce qui est incompréhensible.

En effet, pour une résolution de $32\cdot 10^6$, l'utilisation de la mémoire GPU est de 60 pourcent tandis que pour une résolution de $256 \cdot 10^6$, l'utilisation de la mémoire GPU est seulement de 10 pourcent.

Une explication évidente serait que le pourcentage donné serait le pourcentage de mémoire non utilisée.

```{python}
#| label: fig-3
#| fig-cap: FluidX3D résolution 108000000
fluidx3d('domain_3_2.csv')
```
```{python}
#| label: fig-4
#| fig-cap: FluidX3D résolution 256000000
#fluidx3d('domain_fois_4.csv')
```

