# Comparaison entre les résultats

Dans ce chapitre, une comparaison entre les deux codes est proposée.
Afin de faire un petit rappel, on a comme code :

- GVDB-Voxel : ce code est une implémentation de la méthode SPH en tirant profit des technologies de Nvidia.
- FluidX3D : ce code est une implémentation de la méthode LBM en utilisant OpenCL, ce qui rend le code exécutable sur tous les GPUs.

La comparaison a donc impliqué d'essayer de faire des exemples similaires afin de pouvoir comparer au mieux les deux implémentations des méthodes.

La stabilité numérique des deux méthodes SPH et LBM repose principalement sur l'initialisation de celles-ci, c'est pourquoi la recherche des paramètres rendant les deux méthodes identiques est un problème très complexe.

## Initialisation de la simulation

La condition initiale joue un rôle crucial dans la comparaison des deux codes car l'objectif est de comparer les deux codes grâce à la modélisation du même phénomène physique.
La première idée était de modéliser une goutte, en forme de cube car plus facile à définir, tombant dans un bassin d'eau, comme il est possible de voir sur la figure [-@fig-idee-1].

![Idée initiale](../images/idee-1.png){#fig-idee-1 width=60%}

À cet exemple, le travail a montré que la définition d'un bac d'eau était presque impossible dans l'implémentation de la méthode SPH, car celle-ci possède des instabilités au niveau des bords du domaine, c'est pourquoi le fluide implosait ou s'éparpillait en volant dans tout le domaine, comme il est possible de voir sur la figure [-@fig-problem-1].
En plus du phénomène d'implosion, le code s'arrêtait au bout d'un petit moment à cause d'accès illégaux à la mémoire.

::: {#fig-problem-1 layout-ncol=2}

![Condition initiale](../images/problem-1-1.png){width=70%}

![Implosion](../images/problem-1-2.png){width=60%}

Difficulté de définir un bac d'eau
:::

Face à ces difficultés, la solution finale a été de renoncer à cette comparaison qui aurait été idéale car elle aurait permis de faire varier la quantité d'eau dans le bac, permettant de voir à quel point le code avec domaine adaptatif était avantagé comparé à l'autre code qui aurait eu plus de peine à tourner pour un bac très rempli d'eau car il aurait dû calculer ce qui se passe au fond du bac, ce qui n'aurait pas été le cas du code avec domaine adaptatif.

C'est pourquoi l'exemple choisi est un exemple fonctionnel modifié de la méthode SPH.
Dans l'exemple original, il y avait ensuite une force fréquentielle qui créait des vagues dans le bac, mais celle-ci a été supprimée afin de pouvoir avoir le même exemple dans les deux codes.

Il s'agit d'un cuboïd d'eau tombant dans un bac, comme il est possible de voir sur la séquence d'images [-@fig-sequence].
Cet exemple a été reproduit dans les deux codes, c'est pourquoi la séquence d'images [-@fig-sequence] est celle de FluidX3D.


::: {#fig-sequence layout-nrow=2}

![](../images/seq1.png)

![](../images/seq2.png)

![](../images/seq3.png)

![](../images/seq4.png)

![](../images/seq5.png)

![](../images/seq6.png)

Séquence d'images de la simulation sans raytracing
:::

Le raytracing a été désactivé pour toutes les images de FluidX3D car le rendu dans le rapport ne permet pas de bien voir le fluide, comme le représente la figure [-@fig-compar].

::: {#fig-compar layout-ncol=2}

![](../images/seq15.png){width=70%}

![](../images/seq5.png){width=70%}

Comparaison de rendu avec et sans raytracing
:::

Comme le code GVDB est conçu pour modéliser des simulations à grande échelle comme l'océan par exemple et que le code de FluidX3D est plus dans le domaine du mètre, les deux exemples ne sont théoriquement pas identiques, c'est pourquoi les paramètres ont été définis afin que les deux codes donnent visuellement les mêmes résultats.

Ainsi, ce ne sera pas une comparaison quantitative, mais qualitative qui sera faite.

Il est possible de voir sur la figure [-@fig-quality] 3 résolutions différentes pour FluidX3D et une résolution pour GVDB-Voxel.

Pour chacune des résolutions de FluidX3D, le paramètre de tension de surface a été ajusté afin d'avoir un résultat qualitativement similaire à GVDB-Voxel.

Afin de faciliter la prise de décision, un rendu très basique a été effectué sur FluidX3D en n'utilisant que de la rastérisation et non du raytracing. 

Comme la figure [-@fig-quality] montre, la perspective n'est pas présente dans GVDB-Voxel, à la différence de FluidX3D.

De plus, en comparant les résultats visuels de la figure [-@fig-problem-1] et de la figure [-@fig-quality], il apparaît que l'isosurface est calculée dans le cas de FluidX3D, mais pas dans le cas de GVDB-Voxel, l'isosurface étant ce qui permet de passer d'une représentation discrète du fluide comme un ensemble de particules à une représentation lisse.

::: {#fig-quality layout-nrow=2}

![GVDB: 1500000 particules](../images/gvdb-voxel-key-1.png){width=85%}

![FluidX3D: Résolution de 4000000](../images/seq5.png)

![FluidX3D: Résolution de 32000000](../images/domain_normal_simple.png)

![FluidX3D: Résolution de 108000000](../images/domain_3_2_simple.png)

Comparaison des qualités
:::

Sur la figure [-@fig-quality], la résolution de FluidX3D semblant équivalente à la résolution de GVDB-Voxel est la résolution de $4 \cdot 10^6$.

En effet, les résolutions de $32 \cdot 10^6$ et $108 \cdot 10^6$ donnent plus de détails que GVDB-Voxel quant à la crête des vagues.

Ainsi, ce sera la résolution de $4 \cdot 10^6$ qui sera utilisée afin de comparer les deux codes.

Les tailles des domaines ont été choisies afin d'obtenir un résultat similaire.

Dans le cas de GVDB-Voxel, le domaine est de taille $400 \times 400 \times 200$ tandis que dans le cas de FluidX3D, le domaine est de taille $200 \times 200 \times 100$.

Ainsi, les deux domaines sont proportionnels, mais pas identiques car la résolution de FluidX3D est contrôlée par la taille du domaine.

Comme le code de GVDB-Voxel possède $1.5 \cdot 10^6$ particules, les propriétés de celles-ci telles que leur position, leur vitesse, leur masse etc. doivent être stockées.

Au contraire, dans le code de FluidX3D, comme le domaine est de taille $200 \times 200 \times 100$, la résolution est de $200 \cdot 200 \cdot 100 = 4 \cdot 10^6$ donnant les informations de $4\cdot 10^6$ lattices à stocker.
Le code de FluidX3D tourne en D3Q19 [-@sec-methode-lbm], ce qui signifie que la discrétisation de la vélocité donne 19 valeurs à stocker.
Donc pour chaque lattice, au moins 19 valeurs sont à stocker ne serait-ce que pour la vélocité.
Ainsi, le code de FluidX3D devrait utiliser plus de mémoire que le code de GVDB-Voxel.

Pour la comparaison des deux méthodes, comme le code de GVDB-Voxel utilise du raytracing natif CUDA s'apparentant à de la rastérisation, le code de FluidX3D a été évalué avec et sans raytracing.

### Moments clés

Lors de la simulation, 2 moments clés ont été définis.
Le premier moment clé est utilisé afin d'ajuster la viscosité pour avoir un résultat similaire entre FluidX3D et GVDB-Voxel, et le deuxième moment clé indique la fin de la simulation, comme il est possible de voir sur la figure [-@fig-key].

:::{#fig-key layout-ncol=2}

![](../images/gvdb-voxel-key-1.png)

![](../images/seq5.png)

![](../images/gvdb-voxel-key-2.png)

![](../images/seq6.png)

Moments clés
:::

Sur la figure [-@fig-key], il est possible de remarquer que le volume d'eau n'est pas le même dans le code de GVDB que dans le code de FluidX3D.
En effet, le fluide s'écrase et se compresse systématiquement sur GVDB-Voxel, comme montré sur la figure [-@fig-compress].

:::{#fig-compress layout-ncol=2}

![Initialisation](../images/compress-init.png){width=60%}

![Compression](../images/compress-final.png){width=60%}

Phénomène de compression dans GVDB
:::

Afin de résoudre le phénomène de compression, un jeu sur de nombreux paramètres du code de GVDB-Voxel, tels que la taille des particules, l'espacement, la densité etc. a été effectué, mais sans succès.

## Exécution des codes {#sec-comparaison}

Dans cette partie, l'objet d'étude sera l'exécution des deux codes.

Les deux codes donnent une visualisation en temps réel, c'est à dire que le rendu est exécuté en même temps que le calcul de la simulation.

La machine ayant servi à l'exécution des deux codes est composée d'un processeur Ryzen 9 7950X3D, d'une carte graphique Nvidia RTX 4080 et de 16 Go de mémoire vive.

Afin d'évaluer les performances des deux codes, un script bash a été créé pour reporter l'utilisation du CPU, de la RAM, et du GPU dans un fichier `csv`.

À cet instant du travail, un souci s'est présenté : le code de FluidX3D ne fonctionne pas en visualisation en temps réel sur le linux de nom ordinateur. En effet, des erreurs XrandR sont apparues lors de l'exécution du code, erreurs qui sont restées irrésolues faute de temps et de documentation sur la provenance de ces erreurs.
Mes suppositions à l'heure actuelle sont que Nvidia utilise X11 avec Xinemara qui est une autre version de XrandR, rendant l'affichage incompatible avec mon ordinateur linux.
La solution n'étant pas trouvée, l'enregistrement des performances a été effectué sous Windows pour le code de FluidX3D, ce qui ne devait pas être trop problématique étant donné que les données principales qui nous intéressent, à savoir l'utilisation du GPU, se prennent avec `nvidia-smi` sur linux et Windows.
Cependant, il a fallu traduire le script bash en script powershell, ce qui s'est fait avec l'aide de ChatGPT et des discussions sur les forums et les blogs.

Enfin, la visualisation des données a été faite à l'aide de python et de ChatGPT qui a donné le squelette du code, permettant d'économiser du temps de codage au profit du rapport.

Les résultats obtenus sont alors donnés sur les figures [-@fig-g1], [-@fig-1] et [-@fig-raytracing].

```{python}
#| label: fig-g1
#| fig-cap: GVDB Voxel 1500000 particules

import matplotlib.pyplot as plt
import pandas as pd

# Lire les données du fichier CSV
log_file = "../../../gvdb-voxels/logs"
def gvdb(log_file: str = 'domain_normal.csv'):
    df = pd.read_csv("../../../gvdb-voxels/logs/" + log_file)
    
    # Afficher les premières lignes pour vérifier le contenu
    # print(df.head())
    
    # Convertir la colonne 'Timestamp' en datetime
    df["Timestamp"] = pd.to_datetime(df["Timestamp"])
    
    # Calculer les secondes depuis le début
    start_time = df["Timestamp"].iloc[0]
    df["Seconds_Since_Start"] = (df["Timestamp"] - start_time).dt.total_seconds()
    
    # Tracer les graphiques de l'utilisation du CPU, de la mémoire et du GPU
    plt.figure(figsize=(14, 7))
    plt.plot(df["Seconds_Since_Start"], df["CPU_Usage(%)"], label="Utilisation CPU (%)")
    # plt.plot(df["Seconds_Since_Start"], df["Memory_Usage(%)"], label="Utilisation Mémoire CPU (%)",)
    plt.plot(df["Seconds_Since_Start"], df["RAM_Usage(%)"], label="Utilisation RAM (%)")
    plt.plot(df["Seconds_Since_Start"], df["GPU_Usage(%)"], label="Utilisation GPU (%)")
    plt.plot(
        df["Seconds_Since_Start"],
        df["GPU_Memory_Usage(%)"],
        label="Utilisation Mémoire GPU (%)",
    )
    plt.plot(
        df["Seconds_Since_Start"],
        df["GPU_Memory_Access_Usage(%)"],
        label="Accès à la Mémoire GPU (%)",
    )
    plt.xlabel("Temps (secondes)")
    plt.ylabel("Utilisation (%)")
    plt.title(
    "Utilisation du CPU, de la Mémoire CPU, du GPU, de la Mémoire GPU, des accès à la mémoire GPU et de la RAM"
    )
    plt.legend()
    plt.grid(True)
    plt.show()
gvdb()
```



::: {#fig-results layout-nrow=2}

```{python}
#| label: fig-1
#| fig-cap: FluidX3D résolution 4000000 sans raytracing

import matplotlib.pyplot as plt
import pandas as pd

# Lire les données du fichier CSV
log_file = "../../../FluidX3D/logs/usage_stats_5.csv"

def fluidx3d(log_file: str = 'domain_divide_by_2_simple.csv'):
    df = pd.read_csv("../../../FluidX3D/logs/" + log_file)
    
    # Afficher les premières lignes pour vérifier le contenu
    #print(df.head())
    
    # Convertir la colonne 'Timestamp' en datetime
    df["Timestamp"] = pd.to_datetime(df["Timestamp"])
    
    # Calculer les secondes depuis le début
    start_time = df["Timestamp"].iloc[0]
    df["Seconds_Since_Start"] = (df["Timestamp"] - start_time).dt.total_seconds()
    
    # Tracer les graphiques de l'utilisation du CPU, de la mémoire et du GPU
    plt.figure(figsize=(14, 7))
    plt.plot(df["Seconds_Since_Start"], df["CPU_Usage(%)"], label="Utilisation CPU (%)")
    # plt.plot(df["Seconds_Since_Start"], df["Memory_Usage(%)"], label="Utilisation Mémoire CPU (%)",)
    plt.plot(df["Seconds_Since_Start"], df["RAM_Usage(%)"], label="Utilisation RAM (%)")
    plt.plot(df["Seconds_Since_Start"], df["GPU_Usage(%)"], label="Utilisation GPU (%)")
    plt.plot(
        df["Seconds_Since_Start"],
        df["GPU_Memory_Usage(%)"],
        label="Utilisation Mémoire GPU (%)",
    )
    plt.plot(
        df["Seconds_Since_Start"],
        df["GPU_Memory_Access_Usage(%)"],
        label="Accès à la Mémoire GPU (%)",
    )
    plt.xlabel("Temps (secondes)")
    plt.ylabel("Utilisation (%)")
    plt.title(
    "Utilisation du CPU, de la Mémoire CPU, du GPU, de la Mémoire GPU, des accès à la mémoire GPU et de la RAM"
    )
    plt.legend()
    plt.grid(True)
    plt.show()
fluidx3d()
```

```{python}
#| label: fig-raytracing
#| fig-cap: FluidX3D résolution 4000000 avec raytracing
fluidx3d('usage_stats_raytracing.csv')
```

Résultats obtenus pour FluidX3D
::: 

\newpage

## Interprétation des résultats

Il est possible d'observer à la fin du graphique de la figure [-@fig-1] que toutes les valeurs diminuent soudainement.
Cela est causé par un signal d'arrêt envoyé au programme entre l'enregistrement de 2 mesures, donnant une valeur mauvaise car la mesure utilise le PID du processus en cours d'exécution, qui est détruit par le signal.

La première observation, qu'il est possible de faire sur les deux graphiques obtenus dans la figure [-@fig-results], est que le temps d'exécution des deux codes diffère d'un facteur $10$.
En effet, le code de FluidX3D est exécuté en approximativement $3$ secondes alors que le code de GVDB-Voxel est exécuté en environ $30$ secondes.

Cette différence est crutiale et semble indiquer clairement quel code est le plus efficace.

Cependant, un grand nombre de données ont été fournies par les scripts d'évaluation de performance, c'est pourquoi une étude plus en détail va être effectuée.

### Utilisation du CPU et de la RAM

Les graphiques de la figure [-@fig-results] donnent de nombreuses informations intéressantes, notamment le pourcentage d'utilisation du CPU ou processeur et de la RAM ou mémoire vive.

Une première constatation est alors que le code de GVDB-Voxel n'utilise pas du tout le CPU, à la différence de FluidX3D.
Ainsi, le code de GVDB-Voxel s'exécute entièrement sur GPU ou carte graphique.

Cependant, le code FluidX3D n'utilise que très peu le CPU car son utilisation est inférieur à 20 %.
Il se sert du CPU surtout au début du lancement du code ou la valeur est plus élevée, comme la figure [-@fig-1] le montre.
Donc le code de FluidX3D s'exécute presque entièrement sur GPU.

Comme l'utilisation de la RAM est avoisinant les 1 % pour les deux codes, on peut considérer l'utilisation de celle-ci comme étant nulle.

### Utilisation du GPU

Afin de caractériser l'utilisation du GPU, 3 valeurs ont été retenues :

- Le pourcentage de mémoire GPU utilisée par le processus.
- Le pourcentage de puissance de calcul du GPU utilisée par le processus. 
- Le pourcentage d'accès à la mémoire du GPU.

Comme mentionné précédemment, étant donné le nombre de données à stocker dans les deux codes, on s'attend à avoir le code de FluidX3D utilisant plus de mémoire GPU que le code de GVDB-Voxel.
Cependant, il n'en est rien car les deux codes utilisent environ 8 % de la mémoire du GPU.

De plus, les deux codes exploitent toute la puissance du GPU car ils sont tous les deux à 95 % d'utilisation de la puissance du GPU, comme semblent le montrer les graphiques de la figure [-@fig-results].

Quant au pourcentage d'accès à la mémoire, le code de FluidX3D est à 50% alors que le code de GVDB-Voxel est à moins de 20%, comme les graphiques [-@fig-1] et [-@fig-g1] le représentent.

Étant donné que la même quantité de mémoire est utilisée, une explication serait que FluidX3D solliciterait beaucoup plus la mémoire car, comme il calcule plus rapidement les prochaines étapes de la simulation, il a également plus rapidement besoin de récupérer les étapes calculées précédemment et stockées en mémoire.
Ainsi, si le code de GVDB-Voxel mettait le même temps d'exécution que le code de FluidX3D, les accès à la mémoire ne seraient pas répartis sur 30 secondes ce qui ferait un pourcentage d'accès à la mémoire plus élevé, bien que grâce à la technologie GVDB [-@sec-gvdb], il pourrait cependant avoir un pourcentage d'accès à la mémoire moins grand que FluidX3D.

Comme le code de GVDB-Voxel possède un pourcentage d'accès à la mémoire moins grand que FluidX3D et un temps d'exécution 10 fois plus élevé que le temps d'exécution de FluidX3D, cela signifie que les étapes de calcul du comportement du fluide prennent plus de temps dans l'implémentation GVDB-Voxel de la méthode SPH comparé à l'implémentation FluidX3D de la méthode LBM.
En effet, les accès à la mémoire sont l'élément le plus coûteux en temps lors de l'exécution d'un code.

De plus, la figure [-@fig-raytracing] montre les performances obtenues pour le code de FluidX3D avec raytracing.
Les performances observées sont identiques aux performances observées sans raytracing.


Ainsi, le code de GVDB-Voxel semble moins bien optimisé que le code de FluidX3D qui donne des performances remarquables.
Cela peut être dû grandement aux améliorations et à l'optimisation des technologies qui a seulement pu profiter au code de FluidX3D et non de GVDB-Voxel qui n'a pas été mis à jour depuis 2018, soit depuis 6 ans.
La différence observée peut également être dûe soit au choix de la méthode, la méthode LBM étant peut-être objectivement plus rapide que la méthode SPH, soit à l'implémentation qui dans le cas de FluidX3D reçoit régulièrement des mises à jour, des optimisations ou encore des ajouts de fonctionnalités tandis que dans le cas de GVDB-Voxel, aucune mise à jour n'est faite, ce qui peut signifier que soit le code est parfait, ce qui serait étonnant vu les difficultés rencontrées à l'initialisation de la méthode SPH et vu le peu de documentation expliquant les paramètres utilisés dans le code, soit le code est certes un bon code, mais pas forcément très optimisé ni sans erreurs.
