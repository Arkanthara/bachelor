# La containerisation

Dans ce rapport, beaucoup de théorie a déjà été faite sur différentes méthodes de simulation de fluides.
Cela est dû en grande partie parce qu'il est important de savoir comment fonctionnent ces méthodes, d'autant plus que l'essort de l'intelligence artificielle met sur le plan secondaire l'implémentation du code.

Je me permettrai d'utiliser un jargon informatique dans ce chapitre pour plus de clarté.
Pour la petite histoire, un jour ma mère m'a demandé ce que j'avais fait, et je lui ai répondu "J'ai enlevé des insectes de ma poubelle" ce qui signifie en jargon informatique "j'ai enlevé des bugs dans mon container"

Dans ce chapitre, la containerisation sera étudiée de plus près car elle a grandement fait partie de mon projet de bachelor.

En effet, j'ai dû reprendre une application qui datait de 2017-2018 et qui ne fonctionnait plus car elle n'était plus compatible avec les librairies actuelles.
Une tentative infructueuse a été faite pour installer les librairies datant de 2017-2018.
Pour exécuter le code, il a donc fallu modifier celui-ci afin de le rendre compilable.

Cependant, comment compiler le code sur plusieurs machines différentes n'ayant pas forcément les mêmes librairies installées ?
C'est à cet instant que la containerisation a montré toute son utilité.

## Notions générales

Un ordinateur ne comprend que des zéros et des uns, ce qui n'est pas le cas de l'homme.
C'est pourquoi, il y a toujours un système d'exploitation qui tourne sur l'ordinateur afin de servir d'interface entre l'homme et la machine.
Un système d'exploitation est composé d'un noyau ou kernel, d'outils systèmes et de librairies permettant à l'utilisateur d'interagir avec la machine, contrôlée par le noyau.

Une machine virtuelle (VM) est une émulation d'un système informatique physique, créée par un logiciel de virtualisation. Elle permet d'exécuter un système d'exploitation complet et ses applications sur un matériel virtuel, indépendamment du matériel physique sous-jacent. Les machines virtuelles offrent une isolation forte, une grande flexibilité et sont largement utilisées dans diverses applications informatiques (ChatGPT).

Les machines virtuelles sont gérées par un hyperviseur, comme il est possible de le voir sur la figure [-@fig-vm], qui s'occupe alors notamment de l'isolation et de la gestion des ressources des machines virtuelles.

Ainsi, il est possible de mettre une application sur une machine virtuelle car toutes ses dépendances pourront être installées sur le système d'exploitation du matériel virtuel.
L'application pourra alors fonctionner sur n'importe quel matériel physique possédant un hyperviseur pour machines virtuelles.

Cependant, un système d'exploitation occupe beaucoup de mémoire.
Par exemple, Windows 10 occupe environ 20Go de mémoire.
Donc est-ce nécessaire de déployer une machine virtuelle pour une application qui fait seulement 10Mo ? Ou alors est-ce une perte de place ?
Et est-ce vraiment utile d'avoir toutes les fonctionnalités du système d'exploitation pour déployer l'application, ou peut-on se contenter de seulement quelques fonctionnalités ?

Les containers apportent une solution à ce problème.
En effet, un container ne virtualise non pas le matériel, comme le stockage ou la mémoire, mais un système d'exploitation, ce qui signifie que le container n'a pas besoin d'avoir son propre système d'exploitation.
C'est un grand gain de stockage.
Cela permet également de n'utiliser que les fonctionnalités du système d'exploitation qui sont nécessaires au bon fonctionnement du container.
Il en résulte que les containers ont un impact beaucoup plus faible sur les performances du matériel physique qu'une machine virtuelle.
Le principe du container est simple : mettre dedans le code et toutes ses dépendances afin de pouvoir l'exécuter sur n'importe quel système.
Les containers sont gérés par un démon, comme le montre la figure [-@fig-container].

::: {#fig-contvsvm layout-ncol=2}

![Container](../images/container.png){#fig-container width=75%}

![VM](../images/vm.png){#fig-vm width=75%}

Virtual Machine (VM) et container [-@Liam]
:::

## Pourquoi utiliser la containerisation ?

Dans mon projet de bachelor, je me suis occupé de rendre fonctionnel un code qui n'a pas eu de maintenance depuis 2018 environ.

J'ai donc dû comprendre ce qui ne fonctionnait pas et le rendre exécutable, ce qui fut un défi résolu avec succès.
Ici, si l'auteur du code avait créé un container, je n'aurais pas eu besoin de mettre à jour le code, ce qui aurait été beaucoup plus simple.

À ce moment, je ne m'étais toujours pas penché sur la containerisation.

Cependant, le projet avançant, je me suis heurté à des comportements spéciaux du code, et comme celui-ci utilise une carte graphique NVIDIA, je ne pouvais pas montrer à mon professeur encadrant mes problèmes afin de profiter pleinement de ses conseils.
Mais mon professeur possède des serveurs distants équipés de cartes graphiques NVIDIA.

L'objectif était donc d'exécuter le code sur le serveur distant, mais des problèmes de librairies manquantes entre autres sont apparus.

C'est alors que la containerisation a pris toute son importance.

L'idée est d'exécuter un container et d'afficher le résultat graphique du container.

Pour cela, il faut comprendre les mécanismes régissant l'affichage X11.

## Affichage X11 {#sec-x11}

L'affichage X11 est composé notamment de :

- Un serveur Xorg ou X11 qui gère l'affichage et les périphériques d'entrée tels que la souris et le clavier.
  Lors de son démarrage, le serveur X11 crée un socket permettant la communication inter-processus sans passer par le réseau et un fichier de stockage de "magic cookies", généralement appelé `.Xauthority`, afin d'identifier les clients souhaitant afficher quelque chose.
  Le socket sera à l'écoute des connections des applications clientes, 
  Le chemin d'accès au fichier `.Xauthority` est mis dans la variable $XAUTHORITY.
  Lorsqu'une application voudra afficher quelque chose, elle se connectera au socket créé par le serveur et discutera avec celui-ci grâce au socket.
- De "magic cookies" qui sont des jetons d'authentification permettant d'accéder au serveur X11.
  Ils utilisent le hostname, le type de connection et le numéro d'affichage afin de composer un identifiant pour le jeton d'accès.
  Dans l'exemple de "magic cookies" suivant, lizzy est le hostname de mon ordinateur, combiné avec le type de connection qui est unix et le numéro d'affichage.

```{python}
!xauth list | head -n 2
```
  Lorsque le client s'est connecté au socket, il doit s'authentifier auprès du serveur X11, ce qui est fait par l'extraction du "magic cookie" du fichier `.Xauthority` et par l'envoi de ce cookie au serveur.
  Le serveur décide alors si le client a la permission d'afficher ou non.
- Une variable d'environnement ´$DISPLAY´ utilisée afin d'indiquer à l'application cliente quel socket utiliser.
La variable d'environnement est composée de la sorte : `hostname:numéro_d_affichage.numéro_du_serveur_X11`

  - Le hostname indique le nom du host où se trouve le serveur X11.
  - Le numéro d'affichage indique où l'application devra être affichée.
  - Le numéro du serveur X11 est utile s'il y a plusieurs serveurs X11 qui tournent sur une machine.

  Il est possible que la variable `$DISPLAY` soit sous la forme `:0.0`.
  Dans ces conditions, cela signifie que l'affichage se fera sur le serveur X11 local, ce qui peut également s'écrire comme `localhost:0.0`.
  
  La variable d'environnement permet d'indiquer au client le socket à utiliser.

## Affichage d'un container sur ordinateur {#sec-aff-pc}

Toute sorte de codes peuvent être exécutés dans un container, notamment du code donnant un rendu visuel.
La difficulté consiste alors à afficher le rendu visuel sur l'écran, ce qui peut être résolu grâce à la section [-@sec-x11].

Donc pour afficher le rendu visuel du code, il faut donner lors de l'exécution du container la variable d'environnement `$DISPLAY` pour que le container sache quel socket utiliser.
Le socket responsable de la connection avec le serveur et le fichier contenant les cookies d'authentification doivent être partagés, ainsi que le même hostname que l'ordinateur sur lequel tourne le container afin que celui-ci puisse trouver le bon cookie à envoyer au serveur, ce qui est illustré par la figure [-@fig-displaypc].

Il se peut toutefois que le fichier contenant les cookies n'existe pas.
C'est pourquoi, il faut d'abord penser à le créer, puis à créer les cookies.

Cela donne avec docker :

```bash
# Vérifier que .Xauthority existe 
# et le créer avec les cookies du display actuel le cas échéant
if [ ! -e $HOME/.Xauthority ] then
  touch $HOME/.Xauthority
  xauth generate $DISPLAY . trusted
  export XAUTHORITY=$HOME/.Xauthority
fi

docker run --gpus all --runtime nvidia \
  -e DISPLAY=$DISPLAY \ # Partage de la variable $DISPLAY
  -e XAUTHORITY=/home/user/.Xauthority \ # Indication de la location de .Xauthority
  -v /tmp/.X11-unix:/tmp/.X11-unix \ # Partage du socket X11
  -v $XAUTHORITY:/home/user/.Xauthority \ # Partage des cookies
  --hostname $(hostname) \ # Partage du hostname
  mon-application # Image de l'application graphique
```



## Affichage d'un container sur serveur distant

Le fait de pouvoir avoir le rendu visuel d'un container docker est une bonne chose, mais il fallait pouvoir avoir un rendu sur un serveur distant.

Le container s'exécute alors sur un serveur distant.

Une connection ssh avec l'option -X est alors établie afin d'afficher sur l'ordinateur le résultat graphique produit sur le serveur.

Comme le montre la figure [-@fig-displayserver], la connection ssh crée un socket TCP qui transfert par tunnel ssh la sortie visuelle de ce qui est exécuté sur la machine distante.
Le souci est que le socket TCP n'est pas partageable au container à exécuter.
C'est pourquoi, un socket unix redirigé vers le socket TCP est utilisé afin d'envoyer l'affichage dans le tunnel ssh, ce qui est fait au moyen le la commande `socat`.
Notez ici que le socket TCP est identifié par la variable `$DISPLAY` qui est sous la forme `localhost:10` indiquant que le socket TCP écoute sur le port $6000 + 10 = 6010$ pour le transfert X11.
Il faut ensuite bien définir la variable `$DISPLAY` du container afin que celle-ci pointe bien sur le bon socket, c'est à dire le socket unix.
L'authentification du client suit exactement le même principe que pour l'affichage sur un ordinateur [-@sec-aff-pc].

Ainsi il est possible d'écrire le script suivant :

```bash
#!/bin/bash

# Prise du numéro d'affichage
DISPLAY_NUMBER=$(echo $DISPLAY | cut -d. -f1 | cut -d: -f2)

# Création de .Xauthority s'il n'existe pas
if [ ! -e $HOME/.Xauthority ]; then
  touch $HOME/.Xauthority
  xauth generate :$DISPLAY_NUMBER . trusted
  export XAUTHORITY=$HOME/.Xauthority
fi

# Test si on est sur un serveur distant
# et liaision du socket TCP de la connection ssh
# avec le socket UNIX
if echo $DISPLAY | grep -q "localhost"; then
  socat UNIX-LISTEN:/tmp/.X11-unix/X${DISPLAY_NUMBER},fork TCP4:localhost:60${DISPLAY_NUMBER} &
fi

# Lancement de l'application graphique
docker run --gpus all --runtime nvidia \
  -e DISPLAY=:$DISPLAY_NUMBER \
  -e XAUTHORITY=/home/user/.Xauthority \
  -v /tmp/.X11-unix:/tmp/.X11-unix \
  -v $XAUTHORITY:/home/user/.Xauthority \
  --hostname $(hostname) \
  mon-application
```
## Limitations

Cette étape était très intéressante, mais également très chronophage.

En effet, l'application ne marchait tout de même pas sur le serveur du professeur à cause d'une librairie utilisée par le code, notamment la librairie OpenGL.

J'ai donc tenté d'utiliser mon ordinateur fixe, afin de voir si le problème persistait.
Pour cela, une installation et une configuration d'un serveur ssh sécurisé sur mon ordinateur et une reconfiguration de mon routeur a été nécessaire afin d'autoriser les connections depuis l'extérieur.
Malheureusement le problème de librairie était toujours présent et la solution au problème n'a pas encore été trouvée.

```{mermaid}
%%| fig-cap: "Shéma de l'affichage d'une application graphique tournant dans un container sur un ordinateur"
%%| label: fig-displaypc
%%| fig-width: 6.5
flowchart LR
subgraph Ordinateur
    subgraph X[Container]
        subgraph A1[Serveur X11]
            S1[.X11-unix socket]
            C1[magic cookies]
            D1[$DISPLAY]
            E1[$XAUTHORITY]
        end
    end
    subgraph A[Serveur X11]
        H[hostname]
        S[.X11-unix socket]
        C[magic cookies]
    end
end
E[Écran]




S ---|partagé| S1
C --- |partagé|C1
A --> |affichage|E
H --> |donné à l'exécution|X
H --> |autentification|C
D1 --> S1
E1 --> C1
```

```{mermaid}
%%| fig-cap: "Shéma de l'affichage d'une application graphique tournant dans un container sur un serveur distant"
%%| label: fig-displayserver
%%| fig-width: 6.5
flowchart LR
subgraph Ordinateur
    subgraph a[Serveur X11]
        s[.X11-unix socket]
        t[TCP socket]
    end
end
subgraph Serveur
    subgraph X[Container]
        subgraph A1[Serveur X11]
            S1[.X11-unix socket]
            D1[$DISPLAY]
            E1[$XAUTHORITY]
            C1[magic cookies]
        end
    end
    subgraph A[Serveur X11]
        H[hostname]
        S[.X11-unix socket]
        T[TCP socket]
        C[magic cookies]
    end
end
E[Écran]

t <-->|Conenction ssh|T
s <-->|gérée par ssh|t
S <-->|socat|T
S ---|partagé| S1
C --- |partagé|C1
a --> |affichage|E
H --> |donné à l'exécution|X
H --> |autentification|C
D1 --> S1
E1 --> C1
```





