# La containerisation

Dans ce rapport, beaucoup de théorie a déjà été faite sur différentes méthodes de simulation.
Cela est dû en grande partie parce que je considère qu'il est important de savoir comment ça marche avant de comparer les méthodes, et parce que j'ai trouvé la méthodologie très intéressante.

Je me permettrait d'utiliser un jargon informatique dans ce chapitre pour plus de clarté.
En effet, un jour ma mère m'a demandé ce que j'avais fait, et je lui ai répondu "J'ai enlevé des insectes de ma poubelle" ce qui signifie en jargon informatique "j'ai enlevé des bugs dans mon container"

Dans ce chapitre, je vais un peu expliquer la containerisation car cela a fait grandement partie de mon projet de bachelor.

En effet, j'ai dû reprendre une application qui datait de 2017 et qui ne fonctionnait plus car elle n'était plus compatible avec les librairies actuelles et réussir à installer la version de 2017 des librairies est compliqué (je n'y suis pas parvenu).

C'est à cet instant que la containerisation prend toute son importance.

## Notions générales

Un ordinateur ne comprend que des zéros et des uns, ce qui n'est pas le cas de l'homme.
C'est pourquoi, il y a toujours un système d'exploitation qui tourne sur l'ordinateur afin de servir d'interface entre l'homme et la machine.
Un système d'exploitation est composé d'un noyau ou kernel, d'outils systèmes et de librairies permettant à l'utilisateur d'interagir avec la machine, contrôlée par le noyau.

Une machine virtuelle (VM) est une émulation d'un système informatique physique, créée par un logiciel de virtualisation. Elle permet d'exécuter un système d'exploitation complet et ses applications sur un matériel virtuel, indépendamment du matériel physique sous-jacent. Les machines virtuelles offrent une isolation forte, une grande flexibilité et sont largement utilisées dans diverses applications informatiques (ChatGPT).

Les machines virtuelles sont gérées par un hyperviseur, comme il est possible de voir sur la figure [-@fig-vm], qui s'occupe alors notamment de l'isolation et de la gestion des ressources des machines virtuelles.

Ainsi, il est possible de mettre une application sur une machine virtuelle car toutes ses dépendances pourront être installées sur le système d'exploitation du matériel virtuel.
L'application pourra alors fonctionner sur n'importe quel matériel physique possédant un hyperviseur pour machine virtuelles.

Cependant, un système d'exploitation occupe beaucoup de mémoire.
Par exemple, Windows 10 occupe environ 20Go de mémoire.
Donc est-ce nécessaire de déployer une machine virtuelle pour une application qui fait seulement 10Mo ? Ou alors c'est une perte de place ?
Et est-ce que c'est vraiment utile d'avoir toutes les fonctionnalités du système d'exploitation pour déployer l'application, ou alors on peut se contenter de seulement quelques fonctionnalités ?

Les containers sont alors une solution à ce problème.
En effet, un container ne virtualise non pas le matériel (comme le stockage ou la mémoire), mais un système d'exploitation, ce qui signifie qu'ils n'ont pas besoin d'avoir leur propre système d'exploitation, ce qui fait notamment un grand gain de stockage.
Cela permet également de n'utiliser que les fonctionnalités du système d'exploitation qui sont nécessaire au bon fonctionnement du container.
Il en résulte que les containers ont un impact beaucoup plus faible sur les performances du matériel physique qu'une machine virtuelle.
Le principe du container est simple: mettre dedans le code et toutes ses dépendances afin de pouvoir l'exécuter sur n'importe quel système.
Les containers sont gérés par un démon, comme il est possible de voir sur la figure [-@fig-container].

::: {#fig-contvsvm layout-ncol=2}

![Container](../images/container.png){#fig-container width=75%}

![VM](../images/vm.png){#fig-vm width=75%}

Virtual Machine (VM) et container [-@Liam]
:::

## Pourquoi utiliser la containerisation ?

Dans mon projet de bachelor, je me suis occupé de rendre fonctionnel un code qui n'a pas eu de maintenance depuis 2018 environ.

J'ai donc dû comprendre ce qui ne fonctionnait pas et le rendre exécutable, ce qui fut résolu avec succès.
Ici, si l'auteur du code avait créé un container, je n'aurais pas eu besoin de devoir mettre à jour le code, ce qui est beaucoup plus pratique.

À ce moment, je ne m'étais toujours pas penché sur la containerisation.

Cependant, le projet avançant, je me suis heurté à des comportements spéciaux de mon code, et comme celui-ci utilise une carte graphique NVIDIA, je ne pouvais pas montrer à mon professeur encadrant mes problèmes afin d'avoir une piste de déblocage.
Mais mon professeur possède des serveurs distants équipés de cartes graphiques NVIDIA.

On a donc essayé d'exécuter le code sur le serveur distant, mais on s'est heurté à des problèmes de librairies manquantes et d'autres problème.

C'est alors que la containerisation a pris toute son importance dans mon projet de bachelor.

En effet, l'objectif était alors de mettre le code dans un container qui s'exécutera sur le serveur distant du professeur afin de lui montrer mes problèmes et de pouvoir directement essayer des solutions.

L'idée est d'exécuter un container et d'afficher le résultat graphique du container.

Pour cela, il faut comprendre les mécanismes régissant l'affichage X11.

## Affichage X11

L'affichage X11 est composé notamment de:

- Un serveur Xorg ou X11 qui gère l'affichage et les périphériques d'entrée tel que la souris et le clavier.
- Des "magic cookies" qui sont des jetons d'authentifications permettant d'accéder au serveur X11.
  Ils utilisent le hostname et le numéro d'affichage afin de composer un identifiant pour le jeton d'accès.
  Dans l'exemple de "magic cookies" suivant, lizzy est le hostname de mon ordinateur, combiné avec le type de connection utilisée (dans notre cas, le type de connection est unix) et le numéro d'affichage.

```{python}
!xauth list | head -n 2
```
- Une variable d'environnement ´$DISPLAY´ utilisée afin de localiser le serveur X11.
La variable d'environnement est composée de la sorte: `hostname:numéro_d_affichage.numéro_du_serveur_X11`

  - Le hostname indique le nom du host où se trouve le serveur X11.
  - Le numéro d'affichage indique où l'application devra être affichée.
  - Le numéro du serveur X11 est utile s'il y a plusieurs serveurs X11 qui tournent sur une machine.

  Il est possible que la variable `$DISPLAY` soit sous la forme `:0.0`.
  Dans ces conditions, cela signifie que l'affichage se fera sur le serveur X11 local, ce qui peut également s'écrire comme `localhost:0.0`.

## Affichage d'un container sur ordinateur

Le principe est simple: on connecte le socket du serveur d'affichage X11 au socket d'affichage du container, comme cela on redirige l'affichage interne du container vers l'affichage de notre ordinateur, et on autorise la connection au serveur X11 au moyen de `xhost`, comme nous pouvons le voir sur la figure [-@fig-displaypc]. Un socket est un mécanisme de communication bidirectionnelle entre des processus

```{mermaid}
%%| fig-cap: "Shéma de l'affichage d'une application graphique tournant dans un container sur un ordinateur"
%%| label: fig-displaypc
%%| fig-width: 6
flowchart TD
subgraph Ordinateur
    subgraph X[Container]
        subgraph A1[Serveur X11]
            S1[.X11-unix socket]
            C1[magic cookies]
        end
    end
    subgraph A[Serveur X11]
        H[hostname]
        S[.X11-unix socket]
        C[magic cookies]
        D[$DISPLAY]
    end
end
E[Écran]




S ---|partagé| S1
C --- |partagé|C1
S --> |affichage|E
H --> |donné à l'exécution|X
D --> |donné à l'exécution|X
H --> |autentification|C
```
## Affichage d'un container sur serveur distant

Puis on a essayé d'exécuter le container sur le serveur distant, mais là, un nouveau problème est venu: comment obtenir l'affichage du résultat du code s'exécutant dans le container sur un serveur distant ?

Afin de résoudre ce problème, je me suis penché sur les authentifications régissant l'affichage X11.

En effet, dans mon cas, je devais utiliser l'affichage de l'ordinateur du professeur tout en faisant s'exécuter le code dans un container sur un serveur distant.

```{mermaid}
%%| fig-cap: "Shéma de l'affichage d'une application graphique tournant dans un container sur un serveur distant"
%%| label: fig-displayserver
%%| fig-width: 6
flowchart TD
subgraph Ordinateur
    subgraph a[Serveur X11]
        s[.X11-unix socket]
        t[TCP socket]
    end
end
subgraph Serveur
    subgraph X[Container]
        subgraph A1[Serveur X11]
            S1[.X11-unix socket]
            C1[magic cookies]
        end
    end
    subgraph A[Serveur X11]
        H[hostname]
        S[.X11-unix socket]
        T[TCP socket]
        C[magic cookies]
    end
end
E[Écran]

t <-->|Conenction ssh|T
s <-->|gérée par ssh|t
S <-->|socat|T
S ---|partagé| S1
C --- |partagé|C1
s --> |affichage|E
H --> |donné à l'exécution|X
H --> |autentification|C
```





