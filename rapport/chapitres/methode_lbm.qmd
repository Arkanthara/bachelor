# Méthode LBM

## Histoire {#sec-lbmh}

La "Lattice Boltzman Method" (LBM) est basée sur la méthode "Lattice Gaz Automata" (LGA) qui a été développée par J. Hardy, Y. Pomeau et O. de Pazzis [-@Hardy] en 1973 sous le nom de méthode HPP, qui était basée non pas sur les équations de Navier-Stokes [-@sec-NSE], mais sur les équations de Boltzmann [-@sec-BE].

Cependant, en 1986, U. Frisch, B. Hasslacher et Y. Pomeau ont réussi à obtenir les équations de Naiver-Stokes à partir de la méthode LGA en utilisant une lattice hexagonal [-@Frisch].
La méthode LGA possédait des problèmes, notamment un bruit statistique causé par les approximations de la méthode LGA.

Pour pallier à ce problème, G. McMamara et G. Zanetti ont décidé de négliger les corrélations entre les particules et ont donné la notion de fonction de distribution moyenne dans leur travail [-@McMamara], ce qui a donné naissance à la méthode LBM.
Puis en 1989, Higuera et Jimenez ont simplifié la méthode LBM en définissant un opérateur de collision linéaire [-@Higuera].
Et enfin, un opérateur de collision basé sur le travail de Bhatnagar, Gross et Krook [-@Bhatnagar] a été utilisé par simultanément par Koelman [-@Koelman] et Chen et al. [-@Chen].

De nos jours, la méthode LBM est devenue populaire car elle présente une nouvelle approche efficace dans le domaine "Computational Fluid Dynamics" (CFD) qui ne consiste pas à tenter de résoudre directement les équations de Navier-Stokes [-@sec-NSE], comme par exemple la méthode SPH.

### Principes de base

Comme expliqué dans la section [-@sec-meca], un fluide est composé de plusieurs particules liées entre elles par des liaisons faibles.

La méthode LBM considère que le fluide peut être représenté par un ensemble de populations, qui sont des groupes de particules comme nous montre la figure [-@fig-pop].

```{python}
#| label: fig-pop
#| fig-cap: "Représentation des populations de particule"

import matplotlib.pyplot as plt
import numpy as np

particle_nb = 100

positions = np.random.rand(particle_nb, 2)
speed = np.random.randn(particle_nb, 2)

for i in range(particle_nb):
    speed[i] *= 0.15 / np.linalg.norm(speed[i])

plt.figure(figsize=(5, 5))
#plt.title("Représentation des populations de particules")
plt.scatter(positions[:, 0], positions[:, 1], color='g', label="Particule", s=10)
plt.quiver(positions[:, 0], positions[:, 1], speed[:, 0], speed[:, 1], scale = 5, width=0.004, color = 'g')
plt.xlim(0, 1)
plt.ylim(0, 1)
ax = plt.gca()
ax.set_aspect(1)
ax.set_xticklabels([])
ax.set_yticklabels([])
ax.grid(True)
population = plt.Rectangle((0.6, 0.4), 0.2, 0.2, edgecolor='r', facecolor='none', lw=3, label="Population")
ax.add_patch(population)
plt.legend(loc='upper left')
plt.show()
```

Ainsi, ce ne sont pas des particules, mais des groupes de particules qui sont représentés, c'est pourquoi la physique appliquée ne sera pas déterministe, mais probabiliste.

Comme expliqué dans la section [-@sec-lbmh], la méthode LBM ne repose pas sur les équations de Navier-Stokes [-@sec-NSE], mais sur l'équation de Boltzmann [-@sec-BE], utilisée et adaptée pour résoudre les équations de Navier-Stokes [-@sec-NSE].
Cependant, la méthode LBM n'est pas un solveur pour l'équation de Boltzmann [-@sec-BE].

## Représentation et fonction de distribution

Dans la méthode LBM, le système est représenté comme un ensemble de particules dans une grille ou une lattice, comme nous le montre la figure [-@fig-pop].
Le but est alors de savoir comment vont évoluer ces particules dans la grille, comment celles-ci vont interagir entre elles, quel est leurs mouvements moyen dans le système et quel est leur vitesse.

Dans les équations de Navier-Stokes [-@sec-NSE], il n'y a que 2 variables qui sont la position et le temps, tandis que dans la méthode LBM, la vélocité des molécules est également perçue comme une variable qui pourra être nommée $\xi$ et qui décrit le changement de position $\mathbf{x}$ de la molécule en fonction du temps $t$, comme nous le montre l'équation [-@eq-xi].

$$
\xi = \frac{d\mathbf{x}}{dt}
$$ {#eq-xi}

Comme dans l'équation de Boltzmann [-@sec-BE], la fonction de distribution $f(\xi, \mathbf{x}, t)$ donne le nombre de molécules à une position $\mathbf{x}$ et à un temps $t$ qui se déplacent avec une vitesse $\lVect \xi \rVect_{2}$ dans une direction $\xi$.

La fonction de distribution $f$ est normalisée afin que l'intégration sur la vitesse et la position donne la masse du système, comme nous le montre l'équation [-@eq-ms].

$$
\int d^3 \xi \int d^3 \mathbf{x} f(\xi, \mathbf{x}, t) = M(t)
$$ {#eq-ms}

### Moments de la fonction de distribution

Il est possible de calculer les moments de la distribution $f$.

Ce qui est tout particulièrement intéressant est de calculer les moments de la distribution $f$ en fonction de la vitesse des molécules $\xi$ car cela permet de relier la description à l'échelle des molécules, c'est à dire de la description mésoscopique, à la description macroscopique du fluide tel que la densité, la pression ou encore la vitesse du fluide.
En effet, cela permet de prendre les contributions de chaque molécule afin d'obtenir les propriétés globales du fluide.

#### Moment d'ordre $0$

Le moment d'ordre $0$ par rapport à $\xi$ peut se calculer comme dans l'équation [-@eq-mo0].
Il permet d'obtenir la densité $\rho$ du fluide à une position $\mathbf{x}$ et à un temps $t$ car il résulte de l'intégration en fonction de la vitesse des particules que le résultat consiste à prendre chaque particule sans considérer la vitesse que peuvent avoir ces particules ce qui donne la densité de particules en une position $\mathbf{x}$ pour un temps $t$.

$$
\int d^3 \xi f(\xi, \mathbf{x}, t) = \rho(\mathbf{x}, t)
$$ {#eq-mo0}

#### Moment d'ordre $1$

Le moment d'ordre $1$ par rapport à $\xi$ de la fonction de distribution $f$ peut s'obtenir comme montrée dans l'équation [-@eq-mo1].

$$
\int d^3 \xi \xi \codt f(\xi, \mathbf{x}, t) = \rho u(\mathbf{x}, t)
$$ {#eq-mo1}

Dans l'équation [-@eq-mo1], la fonction $u$ est une fonction donnant la vitesse globale du fluide à une position $\mathbf{x}$ et à un temps $t$.
En d'autres termes, cela donne la vitesse macroscopique du fluide en une position et un temps donnée.

La quantité de mouvement est alors obtenue par l'équation [-@eq-mo1] car elle donne la multiplication de la densité avec la vitesse.

#### Moment d'ordre $2$

La pression du fluide est liée au moment d'ordre $2$ de la fonction de distribution, ce qui ne vas pas être détaillé ici par soucis de simplicité.

## Évolution de la fonction de distribution en fonction du temps

La fonction de densité $f$ contient toutes les propriétés locales du fluide.

Mais comment la fonction $f$ évolue-t-elle au cours du temps ?

Afin de répondre à cette question, il suffit d'observer la dérivée totale de $f$ en fonction du temps $t$, ce qui est calculé dans l'équation [-@eq-deriv] grâce aux règles de chaînage et aux définitions de la vitesse $\xi$ [-@eq-xi]

$$
\begin{aligned}
\frac{df(\xi, \mathbf{x}, t)}{dt}
&= (\frac{dt}{dt} \cdot \frac{\partial}{\partial t} + \frac{d\mathbf{x}}{dt}\cdot \frac{\partial}{\partial \mathbf{x}} + \frac{d\xi}{dt} \cdot \frac{\partial}{\partial \xi}) f(\xi, \mathbf{x}, t) \\
&= (\frac{\partial}{\partial t} + \xi \cdot \frac{\partial}{\partial \mathbf{x}} + \frac{F}{\rho} \cdot \frac{\partial}{\partial \xi}) f(\xi, \mathbf{x}, t) \\
&= \frac{\partial}{\partial t}f + \xi \cdot \nabla_{\mathbf{x}} f + \frac{F}{\rho} \cdot \nabla_{\xi}f \\
\end{aligned}
$$ {#eq-deriv}

Dans l'équation [-@eq-deriv], la force $F$ est appliquée sur une masse volumique $\rho$ plutôt que sur la masse $m$ de chaque particule.
C'est pourquoi, grâce à la relation entre la force, la masse et l'accélération de la 2ème loi de Newton, on obtient le terme $\frac{F}{\rho}$.

### Opérateur de collision $\Omega$

Comme expliqué dans la section [-@sec-nocol], lorsque les collisions ne sont pas négligées, la variation de la fonction de distribution $f$ est donnée par les collisions entre les particules.
C'est pourquoi un opérateur de collision $\Omega$ est défini.

Décrire précisément les collisions entre les particules est une chose difficile et coûteuse.

Cependant, grâce au travail de Bhatnagar, Gross et Krook (BGK) [-@Bhatnagar], comme le système va tendre vers un état équilibré $f^{eq}$ à partir de l'état non équilibré $f$, l'opérateur de collision peut être simplifié en la relaxation de $f$ vers $f^{eq}$ comme l'équation [-@eq-bgk] montre, avec $\tau$ le temps de relaxation.

$$
\Omega (f) =- \frac{1}{\tau} (f - f^{eq})
$$ {#eq-bgk}

La simplification donnée par l'équation [-@eq-bgk] est suffisante pour obtenir le comportement des équations de Navier-Stokes [-@sec-NSE].

### Computation de la méthode LBM

Dans cette partie, $\mathbf{v} = \xi - u$ est considérée comme la vitesse du centre de masse d'une population de particules et les collisions entre particules sont considérées comme étant élastiques ce qui permet de conserver la masse, le moment et l'énergie.

#### Distribution d'équilibre $f^{eq}$

La distribution d'équilibre $f^{eq}$ doit dépendre de la densité $\rho$, de la vitesse du centre de masse $\mathbf{v}$ et de la température $T$ qui donne le degré d'agitation des particules.
De plus, elle ne doit pas dépendre de la direction de la vitesse $\mathbf{v}$, donc elle doit être isotropique.
Après des dérivations, la distribution d'équilibre est donnée par l'équation [-@eq-eqdist], qui est une simplification de la distribution de Maxwell-Boltzmann donnant la distribution des vitesses des particules dans un gaz à l'équilibre thermique.

$$
f^{eq} (\mathbf{v}, \mathbf{x}, t) &= \rho \left(\frac{1}{2\pi RT}\right)^{3/2} e^{-\frac{|\mathbf{v}|^2}{2RT}}
$$ {#eq-eqdist}

#### Discrétisation


L'idée principale est d'utiliser les équations de Boltzmann pour résoudre les équations de Navier-Stokes, ce qui est possible grâce à Chapman-Enskog.

Nous allons simuler l'évolution de la fonction de densité $f$ plutôt que l'évolution de la vitesse et de la pression, ce qui nous intéresse normalement dans un fluide microscopique...

Pourquoi utiliser la méthode Boltzmann ?? En effet, il y a plus de variables, cela a l'air plus difficile...
On utilise cette méthode car elle s'avère plus pratique qu'une discrétisation des équations de Navier-Stokes.

On a donc à
- Discrétiser la fonction de distribution $f$
- Qu'est ce que la lattice boltzman equation (LBE)
- comment sont liés l'équation de Navier-stokes et l'équation de boltzmann ?

Espace: 
$x \rightarrow \Delta x$ (lattice). On prend l'espace et on le décompose en "small lattice nodes" et on résoud l'équation pour chaque noeud du treillis (ou de la lattice...)

Temps:
$t \rightarrow \Delta t$ qui est constant... Donc on résoud lattice boltzmann à un temps t, puis on avance de $\Delta t$.... On peut également faire le temps dynamiquement...

Vélocité:
$f(v, x, t) \rightarrow f_{i}(x, t)$ On discrétise $f$ en terme d'espace de vélocité en autorisant seulement un très petit nombre de directions possibles de direction et de vitesse. (Notation D2Q9: 9 vélocité possibles en 2d... D3Q19: 19 vélocité possibles en 3d)

Vélocité:

Ce que l'on fait est que l'on dit que si on a une molécule ou $f$ n'est pas réellement une molécule, mais un ensemble de molécules
Au lieu de dire $f$ décrit comment les molécules bougent dans toutes les directions, on dit que les molécules peuvent maintenant bouger seulement sur les axes primaires $x$, $y$, $z$ ou elles peuvent bouger sur les diagonales, et elles doivent se déplacer de telle sorte qu'en un pas de temps delta t, elles atteignent exactement l'un des noeuds de treillis voisins.
Donc la discrétisation de l'espace de vélocité est fait de telle sorte qu'il est parfaitement aligné avec la discrétisation temporelle et spacialle.

On doit donc remplacer les intégrales par des sommes finies qui n'ont que peu de termes comme 9 ou 19 plutôt que 1 million
Le mécanisme mathématique derrière cela est "Hermite expansion" que je ne vais pas expliquer.

$$(c_{i}) = \begin{bmatrix} 0 & 1 & 0 & -1 & 0 & 1 & -1 & -1 & 1 \\ 0 & 0 & 1 & 0 & -1 & 1 & 1 & -1 & -1\end{bmatrix} \frac{\Delta x}{\Delta t}$$
pour D2Q9....

Une fois que l'on a fait cela, on écrit $q$ différente population $f_{i}(x, t)$, une pour chaque $c_{i}$

On a donc:

$$
\sum_{i}^{q - 1} f_{i}(x, t) = \rho(x, t)
$$
et 
$$
\sum_{i}^{q - 1} c_{i} f_{i}(x, t) = \rho u(x, t)
$$

Au lieu de l'oppérateur de collision, on utilise l'approximation BGK et l'équation résultante sera la lattice boltzmann equation ou lattice bgk equation (lbgk)

$$
f_{i}(x + c_{i}\Delta t, t + \Delta t) - f_{i}(x, t) = -\frac{\Delta t}{\tau}(f_{i}(x, t) - f_{i}^{eq}(x, t) = \Omega_{i}
$$
avec

- $f_{i}(x + c_{i}\Delta t, t + \Delta t)  - f_{i}(x, t)$ une population $i$ donnée évaluée dans un point $x$ et un temps $t$ et sa contrepartie se sera déplacée de $c_{i} \times \Delta t$ où $c_{i}$ est la vitesse de la population.
- $-\frac{\Delta t}{\tau}(f_{i}(x, t) - f_{i}^{eq}(x, t)$ la distribution $f_{i}$ qui va se relaxer vers la distribution équilibrée $f_{i}^{eq}$ en un temps $\frac{\Delta t}{\tau}$

Ce qui nous donne si on réécrit cela:
$$
f_{i}(x + c_{i}\Delta t, t + \Delta t) = f_{i}(x, t) -\frac{\Delta t}{\tau}(f_{i}(x, t) - f_{i}^{eq}(x, t) = \Omega_{i}
$$

Le terme de relaxation nous donne un déplacement ou une redistribution de notre population, mais elle n'a pas encore bougé dans l'espace, et ensuite, on la propage vers les autres voisins.

Les avantages sont que les collisions sont locales et algébriques: c'est un algorithme très simple pour les collisions et la propagation est linéaire et exacte, ce qui signifie que l'on peut décomposer le lattice solveur en étape de collision et de propagation.

Dans Navier-Stokes, on a la notion de viscosité alors que dans Boltzmann, on a seulement un temps de relaxation.
On a ainsi la relation suivante:
$$
visc = c_{S}^2\left(\tau - \frac{\Delta t}{2}\right)
$$

avec la vitesse du son $c_{S}$ définie comme suit:
$$
c_{S} = \frac{1}{\sqrt{3}}\frac{\Delta x}{\Delta t}
$$

et $f_{i}^{eq}$ qui est une simplification de la distribution de Maxwell-Boltzmann défini comme suit:

$$
f_{i}^{eq} = w_{i} \rho \left(1 + \frac{c_{i} \cdot u}{c_{S}^2} + \frac{(c_{i} \cdot u)^2}{2c_{S}^4} - \frac{u \cdot u}{2c_{S}^2} \right)
$$
avec $w_{i}$ le poids d'une population dépendant de si la population se déplace le long des axes principaux ou diagonaux ou si elle reste sur place ( en effet, il peut changer de valeur suivant ces critères....)

Comment on fait ?

- Condition initiale. On connaît le $f_{i}$ initial. On peut donc calculer la densité et la vélocité par la somme des moments de $f$
- Ensuite, on calcule la distribution équilibrée $f^{eq}$ qui dépend uniquement de la densité et de la vélocité.
- Puis on peut calculer la distribution post collision $f_{i}^*$. Nos populations auront été redistribués dans l'espace de vélocité, mais n'auront pas bougé.
  On peut alors propager cela aux voisins: $f_{i}(x + c_{i}\Delta t, t + \Delta t) = f_{i}^*$.

Pourquoi ça marche ?

- On a une "lattice symetry and isotropy"
- On a la conservation de la masse et de la quantité de mouvement: $\sum_{i}\Omega_{i} = 0$ et $\sum_{i} c_{i}\Omega_{i} = 0$
- Les analyses de Champman-Enskog nous montre que ce que l'on a fait (donc que LBE) est suffisant pour retrouver le comportement de Navier-Stokes.

1. Avantages
   - C'est rapide car c'est une méthode explicite et linéaire en propagation
   - On n'a pas d'équation de poisson à résoudre (à la différence des équations de Navier-Stokes)
   - C'est une méthode locale exepté pour la propagation aux voisins
   - Facilement parallélisable (très scallable: linéaire en fonction du nombre de coeurs...)
   - Les géométries complexes peuvent être implémentées relativement facilement comparée aux autres méthodes

2. Désavantages
   - On ne peut simuler que des "small Knudsen numbers" et des "small Mach numbers"


Ce qu'on a appris

- Discrétiser la distribution $f$
- Discrétiser la vélocité $f(v, x, t) \rightarrow f_{i}(x, t)$
- Simple à implémenter
- $\tau$ détermine la viscosité du fluide
- la méthode est rapide, facilement parallélisable, et peut être utilisée pour résoudre des systèmes complexes de géométrie
- mais la méthode n'est pas faite pour simuler des high Knudsen ou high Mach numbers


Pour simuler des problèmes de différente taille, il faut bien définir les conditions aux bords...
Les conditions aux bords sont nécessaires non seulement mathématiquement, mais aussi physiquement.
En général, on a des approches non structurées (comme la méthode SPH), des approches structurées (comme la méthode LBM)
Il faut faire attention car si on ne s'occupe pas bien des conditions aux bords, le résultat sera mauvais...

La lattice boltzmann a un zoo pour les conditions aux bords car on a plus de variable que dans les équations de Navier-Stokes.
Par exemple, en 3d, on a 4 champs hydrodynamiques, on a la pression et on a la vélocité qui possède 3 composantes et le stress tensor $\sigma$ qui possède 6 composantes (le stress tensor est utilisé pour déterminer ce qui se passe aux bords du fluide....). Cependant, on a plus de populations...
On a 19 ou 27 populations, ce qui signifie que l'on a plus de liberté dans LBM que dans Navier-Stokes, mais que l'on a plus de conditions à imposer et à satisfaire...

D'une manière générale, on manipule des populations $f_{i}$.
Pour savoir ce qui se passe aux conditions, nous devons savoir ce qui vient depuis l'extérieur, donc on va se dire que l'on a un $f$ qui vient de l'extérieur, et on va essayer de déterminer ce qu'il devrait être.

De nombreuses personnes se sont penchés sur le problème de condition aux bords et ils ont déterminer de nombreuses conditions aux bords, ayant chacune leur avantage et leur désavantage.
On a notamment les Bounce-back methods (simple, interpolée, partiellement saturée), les Ghost methods (FH & MLS, GZS, Image-based) et les Immerse Boundary methods (Explicit, Direct forcing, other variants)

On peut par exemple définir pour Bounce-back methode que si on passe la frontière, on a $f_{i} \rightarrow f_{\hat{i}}$ avec $c_{\hat{i}} = - c_{i}$. Ainsi, on n'ajoute pas de nouvelles informations.
Cette méthode marche pour toute les conditions de bord en escalier, est extrêmement simple et ne possède pas d'équivalent dans les CFD (computationnal fluid dynamics)
mais elle n'est pas très précise, il y a des artéfacts numériques et si on bouge les bords, on aura des complications

Conditions de bord immersive (excellent article de Peskin en 2002 !) Un principe de base est que les frontières vont bouger avec le fluide. Cette méthode n'est pas une condition de bord, mais elle ne fait que mimer l'effet d'un bord.

Avantages: pas besoin d'inclure des conditions de bord réelles, l'effet sur le fluide est complètement inclus avec les forces externes, fonctionne pour des bords de n'importe quelle forme

Désavantages: impact sur la précision due à diffuse interface method, le fluide existe à l'intérieur des bords, plus difficile pour les conditions limites autres que l'absence de glissement...

Comme on n'a pas d'équation de poisson à résoudre, lbm est utile pour le calcul haute performance

Explications prise de cette vidéo: @Krueger2.
